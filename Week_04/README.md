# 使用二分查找，寻找一个半有序数组中间无序的地方

## 方法一：暴力破解
遍历整个数组，找数组中最小值的数组下标。这样的时间复杂度是 O(N) 其中 N 是给定数组的大小。
## 方法二：二分查找
由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。
使用二分查找，只是二分查找需要做特殊的判定，判断条件与标准的二分搜索有些不同：
如果数组没有被旋转，是升序排列，就满足 last element > first element，否则则是有被旋转过。
上面的例子中 2 < 4，因此数组旋转过了。这是因为原先的数组为 [0, 1, 2, 4, 5, 6, 7]，通过旋转较小的元素 [0, 1, 2] 移到了后面，也就是 [4, 5, 6, 7, 0, 1, 2]。因此旋转数组中第一个元素 [4] 变得比最后一个元素大。
这意味着在数组中你会发现一个变化的点，这个点会帮助我们解决这个问题，我们称其为变化点。

在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于变化点的特点：
所有变化点左侧元素 > 数组第一个元素
所有变化点右侧元素 < 数组第一个元素

算法：
1. 找到数组的中间元素 mid = left + (right - left)/2；
1. 如果中间元素mid < 数组最后一个元素right，我们需要在 mid 左边搜索变化点，否则在右边搜索变化点。
因为nums[mid] < nums[right]，说明右边的数组是有序的，变化点在左侧mid + 1。
1. 当我们不断往数组两边不断夹逼的时候，最终right - left = 1，mid = left，根据条件2也同样适用，最终变化点落在left指针上。
代码如下：
```java
public int findChangePoint(int[] nums) {
	int len = nums.length;
	int left = 0, right = len - 1;
	while (left < right) {
		int mid = left + (right - left)/2;
		if (nums[mid] < nums[right]) {
			right = mid;
		} else {
			left = mid + 1;
		}
	}
	return left;
}
```

